# -*- coding: utf-8 -*-
"""triage core

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-DvwIlx7vAMelSv6kmp_vPmu2HRFvTiA
"""

import re
import json
from typing import Dict, List, Tuple, Optional

# Simple Levenshtein distance (edit distance)
def levenshtein(a: str, b: str) -> int:
    if a == b:
        return 0
    if len(a) < len(b):
        return levenshtein(b, a)
    if len(b) == 0:
        return len(a)
    previous = range(len(b) + 1)
    for i, c1 in enumerate(a):
        current = [i + 1]
        for j, c2 in enumerate(b):
            insertions = previous[j + 1] + 1
            deletions = current[j] + 1
            substitutions = previous[j] + (c1 != c2)
            current.append(min(insertions, deletions, substitutions))
        previous = current
    return previous[-1]

# If you later use EMCDDA/NPS Discovery, you can also import pandas

# =============================================================================
# 1. CATEGORY DEFAULTS AND BASE DRUG SET (YOUR BRISTOL / CORE DATASET)
# =============================================================================

# Category-level default scores for new drugs

CATEGORY_DEFAULT_SCORE: Dict[str, int] = {
    "opioid":          5,
    "benzodiazepine":  4,
    "gabapentinoid":   3,
    "dissociative":    3,
    "stimulant":       2,
    "psychedelic":     3,

    # HIGH RISK — only synthetic cannabinoids and nitazenes use these
    "synthetic_cannabinoid": 6,
    "nitazene":              7,

    "other":           1,
    "alcohol":         2,
    "unknown":         4,
}


# Canonicalisation: map variant labels to canonical names
NORMALISATION_MAP: Dict[str, str] = {
    "cocaine (low conc)": "cocaine",
    "cocaine (trace)": "cocaine",
    "ketamine (low conc)": "ketamine",
    "ketamine (trace)": "ketamine",
    "bromazolam (low conc.)": "bromazolam",

    # Nitazene spelling variants
    "nitazenes": "nitazene",   # plural
    "nitazine": "nitazene",    # common misspelling
}

# Slang / street names → canonical names (very conservative set)
SLANG_MAP: Dict[str, str] = {
    # Cocaine
    "charlie": "cocaine",
    "coke": "cocaine",
    "blow": "cocaine",
    "snow": "cocaine",

    # Ketamine
    "ket": "ketamine",
    "k": "ketamine",

    # Cannabis
    "weed": "cannabis",
    "bud": "cannabis",
    "ganja": "cannabis",
    "skunk": "cannabis",

    # MDMA
    "mdma": "mdma",      # in case not already normalised
    "mandy": "mdma",
    "molly": "mdma",
    "ecstasy": "mdma",
    "xtc": "mdma",

    # LSD (TripSit will add 'lsd' as a drug)
    "acid": "lsd",
    "tabs": "lsd",

    # Synthetic cannabinoid slang 
    "spice": "generic_synthetic_cannabinoid",
    "k2": "generic_synthetic_cannabinoid",
    "mdmb": "generic_synthetic_cannabinoid",

    # FENTANYL & ANALOGUE SLANG
    "fent": "fentanyl",
    "fenty": "fentanyl",
    "f": "fentanyl",
    "fent analog": "fentanyl",
    "fent analogue": "fentanyl",
    "fentanyl analog": "fentanyl",
    "fentanyl analogue": "fentanyl",
    "para-fluoro": "fentanyl",
    "p-fent": "fentanyl",
    "fluoro-fent": "fentanyl",
}


# Words that should be ignored entirely when parsing input
STOPWORDS = {
    "and", "with", "plus", "&", "then", "after", "before",
    "to", "for", "of", "the", "a", "an"
}

# Base config: substances observed in your Bristol dataset / core set
BASE_DRUG_CONFIG: Dict[str, Dict[str, object]] = {
    # Opioids and related
    "diacetylmorphine": {"category": "opioid", "score": 5},  # heroin
    "6-am":             {"category": "opioid", "score": 5},
    "6-ac":             {"category": "opioid", "score": 4},
    "heroin":           {"category": "opioid", "score": 5},
    "fentanyl":         {"category": "opioid", "score": 6},
    "oxycodone":        {"category": "opioid", "score": 5},
    "morphine":         {"category": "opioid", "score": 5},
    "methadone":        {"category": "opioid", "score": 4},
    "codeine":          {"category": "opioid", "score": 3},
    "buprenorphine":    {"category": "opioid", "score": 3},
    "tramadol":         {"category": "opioid", "score": 3},

         # Nitazenes – modelled as ultra-potent synthetic opioids
    "nitazene": {
        "category": "nitazene",
        "score": 7,   # or 8 if you want nitazenes to exceed fentanyl
    },
    "generic_nitazene": {
        "category": "nitazene",
        "score": 7,
    },



    # Synthetic cannabinoids (SCRAs) — HIGH RISK
    "generic_synthetic_cannabinoid": {
        "category": "synthetic_cannabinoid",
        "score": 6,
    },
    "5f_mdmb_pinaca": {
        "category": "synthetic_cannabinoid",
        "score": 6,
    },
    "5f-adb": {
        "category": "synthetic_cannabinoid",
        "score": 6,
    },
    "mdmb-4en-pinaca": {
        "category": "synthetic_cannabinoid",
        "score": 6,
    },
    "akb48": {
        "category": "synthetic_cannabinoid",
        "score": 6,
    },
    "k2": {
        "category": "synthetic_cannabinoid",
        "score": 6,
    },
    "spice": {
        "category": "synthetic_cannabinoid",
        "score": 6,
    },


    # Benzodiazepines
    "bromazolam":       {"category": "benzodiazepine", "score": 4},
    "alprazolam":       {"category": "benzodiazepine", "score": 4},
    "diazepam":         {"category": "benzodiazepine", "score": 3},
    "clonazepam":       {"category": "benzodiazepine", "score": 4},
    "lorazepam":        {"category": "benzodiazepine", "score": 4},

    # Gabapentinoids
    "pregabalin":       {"category": "gabapentinoid", "score": 3},
    "gabapentin":       {"category": "gabapentinoid", "score": 2},

    # Dissociatives
    "ketamine":         {"category": "dissociative", "score": 3},
    "methoxetamine":    {"category": "dissociative", "score": 3},

    # Stimulants
    "cocaine":                 {"category": "stimulant", "score": 2},
    "cathinone":               {"category": "stimulant", "score": 2},
    "methamphetamine":         {"category": "stimulant", "score": 3},
    "amphetamine":             {"category": "stimulant", "score": 2},
    "mdma":                    {"category": "stimulant", "score": 2},
    "di(beta-phenylisopropyl)amine": {"category": "stimulant", "score": 2},
    "caffeine":                {"category": "stimulant", "score": 1},

    # Psychedelics
    "2-cb":            {"category": "psychedelic", "score": 3},

    # Other / low-risk
    "noscapine":       {"category": "other", "score": 1},
    "papaverine":      {"category": "other", "score": 1},
    "paracetamol":     {"category": "other", "score": 1},
    "sl-164":          {"category": "other", "score": 2},
    "cannabis":        {"category": "other", "score": 1},
    "weed":            {"category": "other", "score": 1},
    "marijuana":       {"category": "other", "score": 1},
    "nicotine":        {"category": "other", "score": 1},
    "alcohol":         {"category": "alcohol", "score": 2},
}


# Global config (will be populated by initialise_drug_config)
DRUG_CONFIG: Dict[str, Dict[str, object]] = {}

# =============================================================================
# 2. TRIPSIT: DRUGS.JSON INGESTION
# =============================================================================

def map_tripsit_category_to_internal(ext_cat: str) -> str:
    """
    Map TripSit 'categories' entries onto the internal categories.
    """
    ext_cat = (ext_cat or "").lower().strip()

    if "opioid" in ext_cat:
        return "opioid"
    if "benzo" in ext_cat or "benzodiazepine" in ext_cat:
        return "benzodiazepine"
    if "stimulant" in ext_cat or "empathogen" in ext_cat:
        return "stimulant"
    if "psychedelic" in ext_cat or "hallucinogen" in ext_cat:
        return "psychedelic"
    if "dissociative" in ext_cat:
        return "dissociative"
    if "depressant" in ext_cat or "barbiturate" in ext_cat:
        return "other"  # could create dedicated 'depressant'
    if "nootropic" in ext_cat or "supplement" in ext_cat or "ssri" in ext_cat:
        return "other"
    # 'habit-forming', 'research-chemical', etc. are meta-tags
    return "other"

def ingest_drug_record(name: str, internal_cat: str, default_score: int) -> None:
    """
    Add or update a single drug entry in DRUG_CONFIG.
    If the drug already exists, keep the higher score (conservative),
    and update category only if the existing category is 'unknown'
    and the new category is more specific.
    """
    name = name.lower().strip()
    if not name:
        return

    if internal_cat not in CATEGORY_DEFAULT_SCORE:
        internal_cat = "other"

    existing = DRUG_CONFIG.get(name)

    if existing:
        # keep highest score
        existing["score"] = max(int(existing["score"]), default_score)

        # update category UNLESS existing one is more specific
        if existing["category"] == "unknown" and internal_cat != "unknown":
            existing["category"] = internal_cat

    else:
        DRUG_CONFIG[name] = {
            "category": internal_cat,
            "score": default_score,
        }


def load_tripsit_drugs(json_path: str) -> None:
    """
    Load TripSit drugs.json and add entries to DRUG_CONFIG.
    """
    with open(json_path, "r", encoding="utf-8") as f:
        data = json.load(f)

    for drug_name, meta in data.items():
        cats = meta.get("categories") or []
        if isinstance(cats, str):
            cats = [cats]

        # Prefer pharmacological tags
        preferred_order = [
            "opioid",
            "benzodiazepine",
            "benzo",
            "stimulant",
            "empathogen",
            "psychedelic",
            "hallucinogen",
            "dissociative",
            "depressant",
            "barbiturate",
        ]

        lc_cats = [c.lower() for c in cats]
        ext_cat_main = ""
        for pref in preferred_order:
            for c in lc_cats:
                if pref in c:
                    ext_cat_main = c
                    break
            if ext_cat_main:
                break

        if not ext_cat_main and lc_cats:
            ext_cat_main = lc_cats[0]

        internal_cat = map_tripsit_category_to_internal(ext_cat_main)
        default_score = CATEGORY_DEFAULT_SCORE.get(internal_cat, 2)

        ingest_drug_record(drug_name, internal_cat, default_score)

def build_alias_maps_from_tripsit(json_path: str) -> None:
    """
    Read TripSit's drugs.json and extend:
      - NORMALISATION_MAP with single-word aliases
      - PHRASE_NORMALISATION with multi-word aliases (e.g. 'crystal meth').
    Canonical name = the main key in drugs.json.
    """
    global NORMALISATION_MAP, PHRASE_NORMALISATION

    with open(json_path, "r", encoding="utf-8") as f:
        data = json.load(f)

    for canonical, meta in data.items():
        canon = canonical.lower().strip()

        # 1) Collect aliases: TripSit usually stores them under 'aliases'
        aliases = meta.get("aliases") or []

        # 2) Optionally also include 'common_names' under properties, if present
        props = meta.get("properties") or {}
        common_names = props.get("common_names") or []
        if isinstance(common_names, str):
            common_names = [common_names]

        for raw in list(aliases) + list(common_names):
            if not raw:
                continue
            alias = raw.lower().strip()

            # simple cleanup: normalise spaces & hyphens
            alias = alias.replace("–", "-")
            alias = alias.replace("_", " ")

            # skip if alias is identical to canonical
            if alias == canon:
                continue

            # Multi-word aliases → phrase normalisation (e.g. "crystal meth")
            if " " in alias:
                # we don't want to clobber your manual entries if already set
                if alias not in PHRASE_NORMALISATION:
                    PHRASE_NORMALISATION[alias] = canon
            else:
                # Single word → normalisation map
                if alias not in NORMALISATION_MAP:
                    NORMALISATION_MAP[alias] = canon


def initialise_drug_config(tripsit_path: Optional[str] = None) -> None:
    """
    Populate DRUG_CONFIG with:
      1. BASE_DRUG_CONFIG
      2. TripSit drugs.json
      3. TripSit alias maps (critical)
    """
    global DRUG_CONFIG
    DRUG_CONFIG = dict(BASE_DRUG_CONFIG)

    if tripsit_path:
        # Load main drug list
        load_tripsit_drugs(tripsit_path)

        # ALSO load all aliases (THIS WAS MISSING)
        build_alias_maps_from_tripsit(tripsit_path)

# =============================================================================
# 3. TRIPSIT COMBO PENALTIES (combos.json)
# =============================================================================

TRIPSIT_STATUS_TO_PENALTY: Dict[str, int] = {
    "dangerous": 6,
    "unsafe": 5,
    "caution": 3,
    "low risk & synergy": 2,
    "low risk & no synergy": 0,
    "low risk & decrease": 0,
    "unknown": 2,  # fallback
}

TRIPSIT_COMBO_PENALTIES: Dict[frozenset, int] = {}
TRIPSIT_COMBO_LABELS: set = set()  # all keys from combos.json (lowercased)


def load_tripsit_combos(json_path: str) -> None:
    """
    Load TripSit's combos.json and create a pairwise penalty map.

    For each (A,B) with a status:
      TRIPSIT_COMBO_PENALTIES[frozenset({A,B})] = penalty

    Keys are stored lowercased; TRIPSIT_COMBO_LABELS holds all labels.
    """
    global TRIPSIT_COMBO_PENALTIES, TRIPSIT_COMBO_LABELS
    TRIPSIT_COMBO_PENALTIES = {}
    TRIPSIT_COMBO_LABELS = set()

    with open(json_path, "r", encoding="utf-8") as f:
        data = json.load(f)

    for substance, partners in data.items():
        s1 = substance.lower().strip()
        TRIPSIT_COMBO_LABELS.add(s1)
        for partner, info in partners.items():
            s2 = partner.lower().strip()
            TRIPSIT_COMBO_LABELS.add(s2)
            status = (info.get("status") or "unknown").lower().strip()
            penalty = TRIPSIT_STATUS_TO_PENALTY.get(status, TRIPSIT_STATUS_TO_PENALTY["unknown"])
            key = frozenset({s1, s2})
            existing = TRIPSIT_COMBO_PENALTIES.get(key, 0)
            TRIPSIT_COMBO_PENALTIES[key] = max(existing, penalty)

def map_drug_to_tripsit_label(drug_name: str) -> str:
    """
    Map a canonical drug name to a TripSit combo label.

    Strategy:
      1. If the canonical name itself is a TripSit label, use it.
      2. Otherwise, use class-based group labels (e.g. 'benzodiazepines',
         'opioids', 'amphetamines', 'stimulants') if those exist in combos.json.
      3. Fallback: return the canonical name (may yield no extra penalty if not present).
    """
    d = drug_name.lower().strip()
    if d in TRIPSIT_COMBO_LABELS:
        return d

    info = DRUG_CONFIG.get(d)
    if not info:
        return d

    cat = str(info["category"])

    # candidate labels by class:
    candidates = []

    if cat == "benzodiazepine":
        candidates.extend(["benzodiazepines", "benzos"])
    if cat == "opioid":
        candidates.extend(["opioids", "opiates", "opiods"])  # misspelling just in case
    if cat == "stimulant":
        if d in {"amphetamine", "methamphetamine"}:
            candidates.append("amphetamines")
        candidates.append("stimulants")
    if cat == "dissociative":
        candidates.append("dissociatives")
    if cat == "psychedelic":
        candidates.append("psychedelics")
    if cat == "alcohol":
        candidates.append("alcohol")
    if cat == "other":
        # try some common ones
        if d in {"cannabis", "weed", "marijuana"}:
            candidates.extend(["cannabis", "weed"])
        if d == "nicotine":
            candidates.append("nicotine")

    for cand in candidates:
        lc = cand.lower()
        if lc in TRIPSIT_COMBO_LABELS:
            return lc

    # fallback
    return d

def compute_tripsit_combo_penalty(drugs: List[str]) -> int:
    """
    Compute additional penalty based on TripSit combo chart.
    """
    if not TRIPSIT_COMBO_PENALTIES:
        return 0

    mapped = [map_drug_to_tripsit_label(d) for d in drugs]
    penalty = 0
    seen_pairs = set()

    for i in range(len(mapped)):
        for j in range(i + 1, len(mapped)):
            key = frozenset({mapped[i], mapped[j]})
            if key in seen_pairs:
                continue
            seen_pairs.add(key)
            penalty += TRIPSIT_COMBO_PENALTIES.get(key, 0)

    return penalty

# =============================================================================
# 4. NORMALISATION + CATEGORY INFERENCE + UNKNOWN HANDLING
# =============================================================================

def normalise_token(token: str) -> str:
    """Lowercase and canonicalise using SLANG_MAP and NORMALISATION_MAP."""
    token = token.lower().strip()

    # First map slang / street names to canonical drug names, if known
    if token in SLANG_MAP:
        token = SLANG_MAP[token]

    # Then apply normalisation rules (trace/low-conc variants, etc.)
    return NORMALISATION_MAP.get(token, token)


def infer_category_from_name(name: str) -> str:
    """
    Heuristic to guess a category for previously unseen drugs.
    """
    n = name.lower()
    if "nitazene" in n:
        return "nitazene"
    if "pinaca" in n or " cannabinoid" in n:
        return "other"
    if "cathinone" in n:
        return "stimulant"
    if n.endswith("pam") or n.endswith("lam"):
        return "benzodiazepine"
    if "ketamine" in n or "methoxetamine" in n or n == "mxe":
        return "dissociative"
    return "unknown"

def fuzzy_match_drug(token: str, known_drugs: list, max_distance: int = 2) -> str:
    """
    Fuzzy match token to closest known drug within max_distance.
    Returns the matched drug, or the original token if no safe match found.
    """
    token = token.lower().strip()
    best_match = None
    best_distance = 999

    for drug in known_drugs:
        dist = levenshtein(token, drug)
        if dist < best_distance:
            best_distance = dist
            best_match = drug

    if best_distance <= max_distance:
        return best_match  # safe correction

    return token  # no correction; handled as unknown


def get_drug_info(raw_token: str) -> Tuple[str, str, int, bool]:
    """
    Given a raw token, return (canonical_name, category, score, is_unknown).

    - If the substance is already in DRUG_CONFIG (BASE/TRIPSIT), it is treated
      as a *known* drug and `is_unknown` is always False.
    - Only substances that are not in DRUG_CONFIG and require on-the-fly
      inference can be flagged as 'unknown'.
    """
    # Normalise and fuzzy-match first
    token = normalise_token(raw_token)
    token = fuzzy_match_drug(token, list(DRUG_CONFIG.keys()))

    # 1) Already known drug → never mark as 'unknown'
    if token in DRUG_CONFIG:
        info = DRUG_CONFIG[token]
        cat = str(info["category"])
        score = int(info["score"])
        # Known drug, regardless of category label
        return token, cat, score, False

    # 2) New / unseen substance → infer category + score
    inferred_cat = infer_category_from_name(token)
    score = CATEGORY_DEFAULT_SCORE[inferred_cat]

    DRUG_CONFIG[token] = {"category": inferred_cat, "score": score}

    # Only truly new / inferred substances can be 'unknown'
    is_unknown = (inferred_cat == "unknown")
    return token, inferred_cat, score, is_unknown

# =============================================================================
# 5. CATEGORY-LEVEL SYNERGY RULES
# =============================================================================

SYNERGY_PAIRS: List[Tuple[str, str]] = [
    ("opioid", "benzodiazepine"),
    ("opioid", "gabapentinoid"),
    ("benzodiazepine", "gabapentinoid"),
    ("opioid", "alcohol"),
    ("benzodiazepine", "alcohol"),
    ("opioid", "dissociative"),
    ("benzodiazepine", "dissociative"),
    ("opioid", "stimulant"),  # speedballing
]
# =============================================================================
# 5a. DRUG PROFILE FLAGS FOR TAILORED RECOMMENDATIONS
# =============================================================================

# Example groupings – aligned to your canonical names.
OPIOID_LIKE = {
    "heroin",
    "diacetylmorphine",
    "6-am",
    "6-ac",
    "morphine",
    "fentanyl",
    "methadone",
    "oxycodone",
    "buprenorphine",
    "codeine",
    "tramadol",
    "nitazene",
    "generic_nitazene",
}

BENZOS = {
    "bromazolam",
    "alprazolam",
    "diazepam",
    "clonazepam",
    "lorazepam",
    # TripSit may add more, but these are common
    "etizolam",
    "flubromazolam",
}

GABAPENTINOIDS = {
    "pregabalin",
    "gabapentin",
}

ALCOHOL_LIKE = {
    "alcohol",
    "ethanol",
}

STIMULANTS = {
    "cocaine",
    "cathinone",
    "methamphetamine",
    "amphetamine",
    "mdma",
    "di(beta-phenylisopropyl)amine",
}

DISSOCIATIVES = {
    "ketamine",
    "methoxetamine",
    "mxe",
}


def classify_drug_profile(canonical_drugs: List[str]) -> dict:
    """
    Return booleans describing the main pharmacological profile
    from a list of canonical drug names.
    """
    lower = {d.lower() for d in canonical_drugs}

    has_opioid_like = bool(lower & OPIOID_LIKE)
    has_benzo = bool(lower & BENZOS)
    has_gabapentinoid = bool(lower & GABAPENTINOIDS)
    has_alcohol = bool(lower & ALCOHOL_LIKE)
    has_stimulant = bool(lower & STIMULANTS)
    has_dissociative = bool(lower & DISSOCIATIVES)

    has_any_depressant = (
        has_opioid_like or has_benzo or has_gabapentinoid or has_alcohol or has_dissociative
    )

    return {
        "has_opioid_like": has_opioid_like,
        "has_benzo": has_benzo,
        "has_gabapentinoid": has_gabapentinoid,
        "has_alcohol": has_alcohol,
        "has_stimulant": has_stimulant,
        "has_dissociative": has_dissociative,
        "has_any_depressant": has_any_depressant,
    }

# =============================================================================
# 6. PERSON-LEVEL CONTEXT MODIFIERS
# =============================================================================

def compute_context_modifier(context: dict, drugs: List[str]) -> Tuple[int, List[str]]:
    """
    Compute an additional score based on person-level vulnerability and history.
    Returns (context_score_adjustment, list_of_reasons).
    """
    ctx_score = 0
    reasons: List[str] = []

    categories = {DRUG_CONFIG[d]["category"] for d in drugs if d in DRUG_CONFIG}
    has_opioid = "opioid" in categories
    has_depressant = bool({"opioid", "benzodiazepine", "gabapentinoid",
                           "dissociative", "alcohol"} & categories)

    age = context.get("age")
    weight = context.get("weight_kg")
    height_cm = context.get("height_cm")
    sex = context.get("sex")  # collected for context / future use, not used in scoring

    opioid_dependent = context.get("opioid_dependent", False)
    homeless = context.get("homeless", False)
    recent_overdose = context.get("recent_overdose", False)
    severe_mental_health = context.get("severe_mental_health", False)
    polysubstance_history = context.get("polysubstance_history", False)

    # Age-related vulnerability
    if age is not None:
        if age <= 18:
            ctx_score += 1
            reasons.append("Young person (<=18) – increased vulnerability.")
        elif age >= 65:
            ctx_score += 2
            reasons.append("Older adult (>=65) – higher risk from CNS depressants.")

    # Body size: use BMI if we have both height and weight, otherwise fall back to simple weight check
    bmi = None
    if weight is not None and height_cm is not None and height_cm > 0:
        height_m = height_cm / 100.0
        bmi = weight / (height_m ** 2)

    if bmi is not None:
        if bmi < 16:
            ctx_score += 2
            reasons.append(
                f"Very low BMI ({bmi:.1f}) – severely underweight, higher effective exposure and frailty."
            )
        elif bmi < 18.5:
            ctx_score += 1
            reasons.append(
                f"Low BMI ({bmi:.1f}) – underweight, higher effective exposure to substances."
            )
    elif weight is not None and weight < 55:
        # Fallback if height is missing
        ctx_score += 1
        reasons.append("Low body weight (<55 kg) – higher effective exposure.")

        # Known opioid dependence – higher baseline risk
    if has_opioid and opioid_dependent:
        ctx_score += 2
        reasons.append("Known or suspected opioid dependence – higher baseline overdose and relapse risk.")

    # Social / clinical vulnerability
    if homeless:
        ctx_score += 3
        reasons.append("Person experiencing homelessness – unstable environment and reduced access to care.")
    if recent_overdose:
        ctx_score += 3
        reasons.append("Recent overdose – strong indicator for relapse and high mortality risk.")
    if severe_mental_health:
        ctx_score += 2
        reasons.append("Severe mental health difficulty – increased overall vulnerability.")
    if polysubstance_history and len(drugs) >= 3:
        ctx_score += 1
        reasons.append("History of polysubstance use plus current multiple substances.")

    # has_depressant, lives_alone, pregnancy, etc. could be added later
    return ctx_score, reasons


# =============================================================================
# 7. DRUG EXTRACTION + SCORING
# =============================================================================
STOPWORDS = {
    "and", "with", "plus", "&", "then", "after", "before",
    "to", "for", "of", "the", "a", "an", "took", "used",
    "had", "take", "taking", "some", "my", "his", "her",
    "their"
}

# Normalise multi-word phrases before tokenising
PHRASE_NORMALISATION = {
    "synthetic cannabinoid": "generic_synthetic_cannabinoid",
    "synthetic cannabinoids": "generic_synthetic_cannabinoid",

    # High-priority manual mappings
    "crystal meth": "methamphetamine",
    "crystal-meth": "methamphetamine",
    "ice (meth)": "methamphetamine",

    # Common typo you accidentally used in the screenshot:
    "cyrstal meth": "methamphetamine",
}

def extract_drugs(text: str) -> Tuple[List[str], List[str]]:
    """
    Parse free text and return:
      - list of canonical drugs,
      - list of 'unknown category' drugs.
      STOPWORDS (e.g. 'and', 'with') are ignored.
    """
    text = text.lower()

    # Apply phrase normalisation BEFORE splitting
    for phrase, replacement in PHRASE_NORMALISATION.items():
        text = text.replace(phrase, replacement)

    tokens = re.split(r"[ ,;\n]+", text)

    detected: List[str] = []
    unknowns: List[str] = []

    for token in tokens:
        # Clean whitespace + hidden characters in one go
        token = token.strip().replace("\r", "").replace("\n", "")

        # Skip empty tokens and filler words like "and"
        if not token or token in STOPWORDS:
            continue

        canonical, cat, score, is_unknown = get_drug_info(token)
        detected.append(canonical)

        if is_unknown:
            unknowns.append(canonical)

    # Remove duplicates
    detected = list(dict.fromkeys(detected))
    unknowns = list(dict.fromkeys(unknowns))

    return detected, unknowns



def compute_drug_score(drugs: List[str]) -> Tuple[int, int, int]:
    """
    Compute:
      base + category-based synergy + TripSit combo penalties.

    Returns:
      (total_drug_score, category_synergy_component, tripsit_combo_component)
    """
    base = 0
    categories = set()

    for d in drugs:
        info = DRUG_CONFIG.get(d)
        if info is None:
            _, cat, score, _ = get_drug_info(d)
        else:
            cat = str(info["category"])
            score = int(info["score"])
        base += score
        categories.add(cat)

    category_synergy = 0
    for c1, c2 in SYNERGY_PAIRS:
        if c1 in categories and c2 in categories:
            category_synergy += 3

    tripsit_combo = compute_tripsit_combo_penalty(drugs)
    total = base + category_synergy + tripsit_combo
    return total, category_synergy, tripsit_combo

# =============================================================================
# 8. TRIAGE BRANCHES, LCMS PRIORITY, REFERRAL LOGIC
# =============================================================================

def triage_branch(score: int) -> str:
    """
    Map the total score to a simple branch label.
    Detailed interventions are now handled separately in build_recommendations().
    """
    if score >= 12:
        return "High risk"
    elif score >= 6:
        return "Moderate risk"
    else:
        return "Low risk"

def lcms_priority(score: int, unknown_drugs: List[str]) -> str:
    if unknown_drugs:
        return "High priority for LCMS confirmation (novel/unmapped substance detected)."
    if score >= 12:
        return "Consider LCMS confirmation if capacity allows (high-risk profile)."
    if score >= 6:
        return "LCMS useful but not essential; prioritise unknown/high-risk samples first."
    return "LCMS generally not required for triage; can be deprioritised if resources are limited."

def build_recommendations(
    canonical_drugs: List[str],
    context: dict,
    branch: str,
    total_score: int,
    unknown_drugs: List[str],
    ctx_reasons: List[str],
) -> Tuple[List[str], List[str], dict]:
    """
    Construct tailored interventions, alerts and referral suggestion
    based on drugs + context + overall risk branch.
    """
    profile = classify_drug_profile(canonical_drugs)
    interventions: List[str] = []
    alerts: List[str] = []

    # --- Base interventions by risk branch (generic framing) ---
    if branch.lower().startswith("high"):
        interventions.append(
            "Urgent clinical assessment recommended. Consider immediate medical review "
            "or emergency services if there are concerning symptoms (reduced consciousness, "
            "breathing difficulties, chest pain, seizures)."
        )
    elif branch.lower().startswith("moderate"):
        interventions.append(
            "Offer same-day or soon clinical review where possible, and provide clear "
            "harm reduction advice based on the substances detected."
        )
    else:  # low risk branch
        interventions.append(
            "Provide brief harm reduction advice tailored to the substances detected and "
            "agree a plan for follow-up or support if needed."
        )

    # --- Drug-specific advice ---

    # Opioids / nitazenes (this is where naloxone is now limited to opioid-like cases)
    if profile["has_opioid_like"]:
        interventions.append(
            "Offer take-home naloxone where available and ensure the person and people "
            "around them know how to recognise and respond to an opioid overdose."
        )
        alerts.append(
            "High risk of respiratory depression from opioids/nitazenes, particularly if "
            "combined with alcohol, benzodiazepines or gabapentinoids."
        )

    # Stimulants without opioids
    if profile["has_stimulant"] and not profile["has_opioid_like"]:
        interventions.append(
            "Offer harm reduction advice for stimulant use (hydration, overheating, "
            "managing comedown, avoiding repeated high doses or long binges)."
        )
        alerts.append(
            "Stimulants can trigger chest pain, arrhythmias, agitation, psychosis or stroke, "
            "especially at high doses or in people with underlying cardiovascular disease."
        )

    # Benzos / gabapentinoids with other depressants
    if (profile["has_benzo"] or profile["has_gabapentinoid"]) and profile["has_any_depressant"]:
        interventions.append(
            "Discuss the high overdose risk from combining benzodiazepines / gabapentinoids "
            "with opioids or alcohol, and explore options to reduce or separate use."
        )
        alerts.append(
            "Benzodiazepines and gabapentinoids can markedly worsen respiratory depression "
            "when taken with opioids or alcohol."
        )

    # Alcohol-heavy picture (without opioids/dissociatives)
    if profile["has_alcohol"] and not profile["has_opioid_like"] and not profile["has_dissociative"]:
        interventions.append(
            "Offer advice on safer drinking (pacing, avoiding mixing with sedatives, "
            "eating beforehand) and explore any concerns about dependence or withdrawal."
        )

    # Dissociatives (e.g. ketamine)
    if profile["has_dissociative"]:
        interventions.append(
            "Provide harm reduction advice for ketamine/dissociatives (dose spacing, "
            "avoiding mixing with alcohol or other sedatives, bladder and mental health risks)."
        )
        alerts.append(
            "Dissociatives can cause accidents, falls and injuries due to impaired perception "
            "and coordination, and repeated use is linked to bladder and mental health problems."
        )

    # --- Contextual alerts (re-use ctx_reasons from compute_context_modifier) ---
    if ctx_reasons:
        alerts.append("Contextual vulnerability factors: " + " ".join(ctx_reasons))

    # --- Unknown substances + LCMS priority ---
    if unknown_drugs:
        alerts.append(
            f"Unidentified substance(s) detected: {', '.join(unknown_drugs)}. "
            "These were assigned to an 'unknown' category with a conservative non-zero "
            "risk score and should be flagged for manual review and potential LCMS confirmation."
        )

    lcms_note = lcms_priority(total_score, unknown_drugs)
    alerts.append(lcms_note)

    # --- Context-sensitive referrals ---
    homeless = context.get("homeless", False)
    recent_overdose = context.get("recent_overdose", False)
    opioid_dependent = context.get("opioid_dependent", False)
    polysubstance_history = context.get("polysubstance_history", False)
    severe_mental_health = context.get("severe_mental_health", False)

    refer = "No"
    priority = "routine"
    reason_parts: List[str] = []
    suggested_service = "Consider local NHS or third-sector drug and alcohol services."

    # Overdose / very high score
    if branch.lower().startswith("high") or total_score >= 12:
        refer = "Yes"
        priority = "urgent"
        reason_parts.append(
            "High acute overdose risk based on substances, combinations and context."
        )

    # Recent non-fatal overdose
    if recent_overdose:
        refer = "Yes"
        priority = "urgent"
        reason_parts.append(
            "Recent non-fatal overdose in the last 3–6 months."
        )

    # Opioid dependence or heavy polysubstance history
    if opioid_dependent or polysubstance_history:
        refer = "Yes"
        if priority != "urgent":
            priority = "soon"
        reason_parts.append(
            "Ongoing dependence / regular polysubstance use; would benefit from structured "
            "treatment or psychosocial support."
        )
        suggested_service = (
            "Local NHS drug and alcohol service (community addiction team, opiate "
            "substitution treatment, psychosocial support)."
        )

    # Homeless or unstable housing – push to homelessness-specific services
    if homeless:
        refer = "Yes"
        if priority != "urgent":
            priority = "soon"
        reason_parts.append(
            "Current homelessness or very unstable housing; consider enhanced outreach "
            "or homelessness-specific services."
        )
        suggested_service = (
            "Local homelessness outreach or integrated drug and alcohol / housing service."
        )

    # Severe mental health difficulty
    if severe_mental_health:
        refer = "Yes"
        if priority == "routine":
            priority = "soon"
        reason_parts.append(
            "Severe mental health difficulty reported; consider joint working with mental "
            "health services or referral for assessment."
        )

    if reason_parts:
        reason = " ".join(reason_parts)
    else:
        reason = "No specific additional referral need identified beyond routine support."

    referral = {
        "refer": refer,
        "priority": priority,
        "reason": reason,
        "suggested_service": suggested_service,
    }

    return interventions, alerts, referral


# =============================================================================
# 9. HIGH-LEVEL TRIAGE FUNCTION
# =============================================================================

def triage_from_text_and_context(text: str, context: dict) -> dict:
    """
    Master function: combines drugs, TripSit penalties, context, LCMS priority,
    and tailored recommendations into one output dict.
    """
    drugs, unknowns = extract_drugs(text)
    drug_score, synergy_component, tripsit_component = compute_drug_score(drugs)
    ctx_score, ctx_reasons = compute_context_modifier(context, drugs)
    total_score = drug_score + ctx_score

    branch = triage_branch(total_score)

    # Build tailored interventions, alerts and referral
    interventions, alerts, referral_info = build_recommendations(
        canonical_drugs=drugs,
        context=context,
        branch=branch,
        total_score=total_score,
        unknown_drugs=unknowns,
        ctx_reasons=ctx_reasons,
    )

    # Add a high-level alert summarising the referral decision
    if referral_info["refer"] == "Yes":
        alerts.append(
            f"Referral recommended ({referral_info['priority']}): {referral_info['reason']} "
            f"→ Suggested pathway: {referral_info['suggested_service']}."
        )
    else:
        alerts.append(
            f"No urgent referral required: {referral_info['reason']} "
            f"→ Suggested pathway: {referral_info['suggested_service']}."
        )

    return {
        "detected_drugs": drugs,
        "unknown_drugs": unknowns,
        "drug_score": drug_score,
        "synergy_component": synergy_component,
        "tripsit_combo_component": tripsit_component,
        "context_score": ctx_score,
        "total_score": total_score,
        "branch": branch,
        "interventions": interventions,
        "alerts": alerts,
        "referral": referral_info,
    }

def get_context_from_user() -> dict:
    """
    Collect person-level context from simple input 'boxes' (prompts).
    Blank answers are treated as unknown / False.
    """
    print("\n--- Client context (leave blank if unknown) ---")

    # Age
    age_str = input("Age: ").strip()
    age = int(age_str) if age_str.isdigit() else None

    # Weight
    weight_str = input("Weight in kg: ").strip()
    try:
        weight_kg = float(weight_str) if weight_str else None
    except ValueError:
        weight_kg = None
        
    # Height (optional)
    height_str = input("Height in cm (optional): ").strip()
    try:
        height_cm = float(height_str) if height_str else None
    except ValueError:
        height_cm = None

    # Sex / gender (optional; collected but not used in score)
    sex_str = input("Sex (e.g. male, female, other; optional): ").strip().lower() or None


    # Yes/No helper
    def yn(prompt: str) -> bool:
        ans = input(prompt + " [y/N]: ").strip().lower()
        return ans in {"y", "yes"}

    opioid_naive = yn("Opioid-naïve (no regular opioid use)?")
    homeless = yn("Is the person currently homeless or in very unstable housing?")
    recent_overdose = yn("Recent non-fatal overdose (e.g. last 3–6 months)?")
    severe_mental_health = yn("Severe mental health difficulty (e.g. psychosis, severe depression)?")
    polysubstance_history = yn("History of regular polysubstance use?")

    context = {
        "age": age,
        "weight_kg": weight_kg,
        "opioid_naive": opioid_naive,
        "homeless": homeless,
        "recent_overdose": recent_overdose,
        "severe_mental_health": severe_mental_health,
        "polysubstance_history": polysubstance_history,
        "weight_kg": weight_kg,
        "height_cm": height_cm,
        "sex": sex_str,
    }

    return context
def pretty_print_result(result: dict) -> None:
    print("\n============ TRIAGE RESULT ============")
    print(f"Detected drugs: {', '.join(result['detected_drugs']) or 'None'}")
    if result["unknown_drugs"]:
        print(f"Unknown drugs (flagged): {', '.join(result['unknown_drugs'])}")

    print(f"\nDrug score: {result['drug_score']}")
    print(f"  - Category synergy component: {result['synergy_component']}")
    print(f"  - TripSit combo component: {result['tripsit_combo_component']}")
    print(f"Context score: {result['context_score']}")
    print(f"TOTAL triage score: {result['total_score']}")

    print(f"\nRisk branch: {result['branch']}")
    print("Recommended interventions:")
    for item in result["interventions"]:
        print(f"  • {item}")

    print("\nAlerts and notes:")
    for a in result["alerts"]:
        print(f"  - {a}")

    print("\nReferral recommendation:")
    ref = result["referral"]
    print(f"  → Refer: {ref['refer']} (priority: {ref['priority']})")
    print(f"  → Reason: {ref['reason']}")
    print(f"  → Suggested service: {ref['suggested_service']}")
    print("=======================================\n")

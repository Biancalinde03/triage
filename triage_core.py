# -*- coding: utf-8 -*-
"""triage core

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-DvwIlx7vAMelSv6kmp_vPmu2HRFvTiA
"""

import re
import json
from typing import Dict, List, Tuple, Optional

# Simple Levenshtein distance (edit distance)
def levenshtein(a: str, b: str) -> int:
    if a == b:
        return 0
    if len(a) < len(b):
        return levenshtein(b, a)
    if len(b) == 0:
        return len(a)
    previous = range(len(b) + 1)
    for i, c1 in enumerate(a):
        current = [i + 1]
        for j, c2 in enumerate(b):
            insertions = previous[j + 1] + 1
            deletions = current[j] + 1
            substitutions = previous[j] + (c1 != c2)
            current.append(min(insertions, deletions, substitutions))
        previous = current
    return previous[-1]

# If you later use EMCDDA/NPS Discovery, you can also import pandas

# =============================================================================
# 1. CATEGORY DEFAULTS AND BASE DRUG SET (YOUR BRISTOL / CORE DATASET)
# =============================================================================

# Category-level default scores for new drugs

CATEGORY_DEFAULT_SCORE: Dict[str, int] = {
    "opioid":          5,
    "benzodiazepine":  4,
    "gabapentinoid":   3,
    "dissociative":    3,
    "stimulant":       2,
    "psychedelic":     3,

    # HIGH RISK — only synthetic cannabinoids and nitazenes use these
    "synthetic_cannabinoid": 6,
    "nitazene":              7,

    "other":           1,
    "alcohol":         2,
    "unknown":         4,
}


# Canonicalisation: map variant labels to canonical names
NORMALISATION_MAP: Dict[str, str] = {
    "cocaine (low conc)": "cocaine",
    "cocaine (trace)": "cocaine",
    "ketamine (low conc)": "ketamine",
    "ketamine (trace)": "ketamine",
    "bromazolam (low conc.)": "bromazolam",

    # Nitazene spelling variants
    "nitazenes": "nitazene",   # plural
    "nitazine": "nitazene",    # common misspelling
}

# Slang / street names → canonical names (very conservative set)
SLANG_MAP: Dict[str, str] = {
    # Cocaine
    "charlie": "cocaine",
    "coke": "cocaine",
    "blow": "cocaine",
    "snow": "cocaine",

    # Ketamine
    "ket": "ketamine",
    "k": "ketamine",

    # Cannabis
    "weed": "cannabis",
    "bud": "cannabis",
    "ganja": "cannabis",
    "skunk": "cannabis",

    # MDMA
    "mdma": "mdma",      # in case not already normalised
    "mandy": "mdma",
    "molly": "mdma",
    "ecstasy": "mdma",
    "xtc": "mdma",

    # LSD (TripSit will add 'lsd' as a drug)
    "acid": "lsd",
    "tabs": "lsd",

    # Synthetic cannabinoid slang 
    "spice": "generic_synthetic_cannabinoid",
    "k2": "generic_synthetic_cannabinoid",
    "mdmb": "generic_synthetic_cannabinoid",

    # FENTANYL & ANALOGUE SLANG
    "fent": "fentanyl",
    "fenty": "fentanyl",
    "f": "fentanyl",
    "fent analog": "fentanyl",
    "fent analogue": "fentanyl",
    "fentanyl analog": "fentanyl",
    "fentanyl analogue": "fentanyl",
    "para-fluoro": "fentanyl",
    "p-fent": "fentanyl",
    "fluoro-fent": "fentanyl",
}


# Words that should be ignored entirely when parsing input
STOPWORDS = {
    "and", "with", "plus", "&", "then", "after", "before",
    "to", "for", "of", "the", "a", "an"
}

# Base config: substances observed in your Bristol dataset / core set
BASE_DRUG_CONFIG: Dict[str, Dict[str, object]] = {
    # Opioids and related
    "diacetylmorphine": {"category": "opioid", "score": 5},  # heroin
    "6-am":             {"category": "opioid", "score": 5},
    "6-ac":             {"category": "opioid", "score": 4},
    "heroin":           {"category": "opioid", "score": 5},
    "fentanyl":         {"category": "opioid", "score": 6},
    "oxycodone":        {"category": "opioid", "score": 5},
    "morphine":         {"category": "opioid", "score": 5},
    "methadone":        {"category": "opioid", "score": 4},
    "codeine":          {"category": "opioid", "score": 3},
    "buprenorphine":    {"category": "opioid", "score": 3},
    "tramadol":         {"category": "opioid", "score": 3},

         # Nitazenes – modelled as ultra-potent synthetic opioids
    "nitazene": {
        "category": "nitazene",
        "score": 7,   # or 8 if you want nitazenes to exceed fentanyl
    },
    "generic_nitazene": {
        "category": "nitazene",
        "score": 7,
    },



    # Synthetic cannabinoids (SCRAs) — HIGH RISK
    "generic_synthetic_cannabinoid": {
        "category": "synthetic_cannabinoid",
        "score": 6,
    },
    "5f_mdmb_pinaca": {
        "category": "synthetic_cannabinoid",
        "score": 6,
    },
    "5f-adb": {
        "category": "synthetic_cannabinoid",
        "score": 6,
    },
    "mdmb-4en-pinaca": {
        "category": "synthetic_cannabinoid",
        "score": 6,
    },
    "akb48": {
        "category": "synthetic_cannabinoid",
        "score": 6,
    },
    "k2": {
        "category": "synthetic_cannabinoid",
        "score": 6,
    },
    "spice": {
        "category": "synthetic_cannabinoid",
        "score": 6,
    },


    # Benzodiazepines
    "bromazolam":       {"category": "benzodiazepine", "score": 4},
    "alprazolam":       {"category": "benzodiazepine", "score": 4},
    "diazepam":         {"category": "benzodiazepine", "score": 3},
    "clonazepam":       {"category": "benzodiazepine", "score": 4},
    "lorazepam":        {"category": "benzodiazepine", "score": 4},

    # Gabapentinoids
    "pregabalin":       {"category": "gabapentinoid", "score": 3},
    "gabapentin":       {"category": "gabapentinoid", "score": 2},

    # Dissociatives
    "ketamine":         {"category": "dissociative", "score": 3},
    "methoxetamine":    {"category": "dissociative", "score": 3},

    # Stimulants
    "cocaine":                 {"category": "stimulant", "score": 2},
    "cathinone":               {"category": "stimulant", "score": 2},
    "methamphetamine":         {"category": "stimulant", "score": 3},
    "amphetamine":             {"category": "stimulant", "score": 2},
    "mdma":                    {"category": "stimulant", "score": 2},
    "di(beta-phenylisopropyl)amine": {"category": "stimulant", "score": 2},
    "caffeine":                {"category": "stimulant", "score": 1},

    # Psychedelics
    "2-cb":            {"category": "psychedelic", "score": 3},

    # Other / low-risk
    "noscapine":       {"category": "other", "score": 1},
    "papaverine":      {"category": "other", "score": 1},
    "paracetamol":     {"category": "other", "score": 1},
    "sl-164":          {"category": "other", "score": 2},
    "cannabis":        {"category": "other", "score": 1},
    "weed":            {"category": "other", "score": 1},
    "marijuana":       {"category": "other", "score": 1},
    "nicotine":        {"category": "other", "score": 1},
    "alcohol":         {"category": "alcohol", "score": 2},
}


# Global config (will be populated by initialise_drug_config)
DRUG_CONFIG: Dict[str, Dict[str, object]] = {}

# =============================================================================
# 2. TRIPSIT: DRUGS.JSON INGESTION
# =============================================================================

def map_tripsit_category_to_internal(ext_cat: str) -> str:
    """
    Map TripSit 'categories' entries onto the internal categories.
    """
    ext_cat = (ext_cat or "").lower().strip()

    if "opioid" in ext_cat:
        return "opioid"
    if "benzo" in ext_cat or "benzodiazepine" in ext_cat:
        return "benzodiazepine"
    if "stimulant" in ext_cat or "empathogen" in ext_cat:
        return "stimulant"
    if "psychedelic" in ext_cat or "hallucinogen" in ext_cat:
        return "psychedelic"
    if "dissociative" in ext_cat:
        return "dissociative"
    if "depressant" in ext_cat or "barbiturate" in ext_cat:
        return "other"  # could create dedicated 'depressant'
    if "nootropic" in ext_cat or "supplement" in ext_cat or "ssri" in ext_cat:
        return "other"
    # 'habit-forming', 'research-chemical', etc. are meta-tags
    return "other"

def ingest_drug_record(name: str, internal_cat: str, default_score: int) -> None:
    """
    Add or update a single drug entry in DRUG_CONFIG.
    If the drug already exists, keep the higher score (conservative).
    """
    name = name.lower().strip()
    if not name:
        return

    if internal_cat not in CATEGORY_DEFAULT_SCORE:
        internal_cat = "other"

    existing = DRUG_CONFIG.get(name)
    if existing:
        existing["score"] = max(int(existing["score"]), default_score)
    else:
        DRUG_CONFIG[name] = {
            "category": internal_cat,
            "score": default_score,
        }

def load_tripsit_drugs(json_path: str) -> None:
    """
    Load TripSit drugs.json and add entries to DRUG_CONFIG.
    """
    with open(json_path, "r", encoding="utf-8") as f:
        data = json.load(f)

    for drug_name, meta in data.items():
        cats = meta.get("categories") or []
        if isinstance(cats, str):
            cats = [cats]

        # Prefer pharmacological tags
        preferred_order = [
            "opioid",
            "benzodiazepine",
            "benzo",
            "stimulant",
            "empathogen",
            "psychedelic",
            "hallucinogen",
            "dissociative",
            "depressant",
            "barbiturate",
        ]

        lc_cats = [c.lower() for c in cats]
        ext_cat_main = ""
        for pref in preferred_order:
            for c in lc_cats:
                if pref in c:
                    ext_cat_main = c
                    break
            if ext_cat_main:
                break

        if not ext_cat_main and lc_cats:
            ext_cat_main = lc_cats[0]

        internal_cat = map_tripsit_category_to_internal(ext_cat_main)
        default_score = CATEGORY_DEFAULT_SCORE.get(internal_cat, 2)

        ingest_drug_record(drug_name, internal_cat, default_score)

def build_alias_maps_from_tripsit(json_path: str) -> None:
    """
    Read TripSit's drugs.json and extend:
      - NORMALISATION_MAP with single-word aliases
      - PHRASE_NORMALISATION with multi-word aliases (e.g. 'crystal meth').
    Canonical name = the main key in drugs.json.
    """
    global NORMALISATION_MAP, PHRASE_NORMALISATION

    with open(json_path, "r", encoding="utf-8") as f:
        data = json.load(f)

    for canonical, meta in data.items():
        canon = canonical.lower().strip()

        # 1) Collect aliases: TripSit usually stores them under 'aliases'
        aliases = meta.get("aliases") or []

        # 2) Optionally also include 'common_names' under properties, if present
        props = meta.get("properties") or {}
        common_names = props.get("common_names") or []
        if isinstance(common_names, str):
            common_names = [common_names]

        for raw in list(aliases) + list(common_names):
            if not raw:
                continue
            alias = raw.lower().strip()

            # simple cleanup: normalise spaces & hyphens
            alias = alias.replace("–", "-")
            alias = alias.replace("_", " ")

            # skip if alias is identical to canonical
            if alias == canon:
                continue

            # Multi-word aliases → phrase normalisation (e.g. "crystal meth")
            if " " in alias:
                # we don't want to clobber your manual entries if already set
                if alias not in PHRASE_NORMALISATION:
                    PHRASE_NORMALISATION[alias] = canon
            else:
                # Single word → normalisation map
                if alias not in NORMALISATION_MAP:
                    NORMALISATION_MAP[alias] = canon


def initialise_drug_config(tripsit_path: Optional[str] = None) -> None:
    """
    Populate DRUG_CONFIG with:
      1. BASE_DRUG_CONFIG (Bristol/core set),
      2. Optional TripSit drugs.json (if provided).
    """
    global DRUG_CONFIG
    DRUG_CONFIG = dict(BASE_DRUG_CONFIG)
    if tripsit_path:
        load_tripsit_drugs(tripsit_path)

# =============================================================================
# 3. TRIPSIT COMBO PENALTIES (combos.json)
# =============================================================================

TRIPSIT_STATUS_TO_PENALTY: Dict[str, int] = {
    "dangerous": 6,
    "unsafe": 5,
    "caution": 3,
    "low risk & synergy": 2,
    "low risk & no synergy": 0,
    "low risk & decrease": 0,
    "unknown": 2,  # fallback
}

TRIPSIT_COMBO_PENALTIES: Dict[frozenset, int] = {}
TRIPSIT_COMBO_LABELS: set = set()  # all keys from combos.json (lowercased)


def load_tripsit_combos(json_path: str) -> None:
    """
    Load TripSit's combos.json and create a pairwise penalty map.

    For each (A,B) with a status:
      TRIPSIT_COMBO_PENALTIES[frozenset({A,B})] = penalty

    Keys are stored lowercased; TRIPSIT_COMBO_LABELS holds all labels.
    """
    global TRIPSIT_COMBO_PENALTIES, TRIPSIT_COMBO_LABELS
    TRIPSIT_COMBO_PENALTIES = {}
    TRIPSIT_COMBO_LABELS = set()

    with open(json_path, "r", encoding="utf-8") as f:
        data = json.load(f)

    for substance, partners in data.items():
        s1 = substance.lower().strip()
        TRIPSIT_COMBO_LABELS.add(s1)
        for partner, info in partners.items():
            s2 = partner.lower().strip()
            TRIPSIT_COMBO_LABELS.add(s2)
            status = (info.get("status") or "unknown").lower().strip()
            penalty = TRIPSIT_STATUS_TO_PENALTY.get(status, TRIPSIT_STATUS_TO_PENALTY["unknown"])
            key = frozenset({s1, s2})
            existing = TRIPSIT_COMBO_PENALTIES.get(key, 0)
            TRIPSIT_COMBO_PENALTIES[key] = max(existing, penalty)

def map_drug_to_tripsit_label(drug_name: str) -> str:
    """
    Map a canonical drug name to a TripSit combo label.

    Strategy:
      1. If the canonical name itself is a TripSit label, use it.
      2. Otherwise, use class-based group labels (e.g. 'benzodiazepines',
         'opioids', 'amphetamines', 'stimulants') if those exist in combos.json.
      3. Fallback: return the canonical name (may yield no extra penalty if not present).
    """
    d = drug_name.lower().strip()
    if d in TRIPSIT_COMBO_LABELS:
        return d

    info = DRUG_CONFIG.get(d)
    if not info:
        return d

    cat = str(info["category"])

    # candidate labels by class:
    candidates = []

    if cat == "benzodiazepine":
        candidates.extend(["benzodiazepines", "benzos"])
    if cat == "opioid":
        candidates.extend(["opioids", "opiates", "opiods"])  # misspelling just in case
    if cat == "stimulant":
        if d in {"amphetamine", "methamphetamine"}:
            candidates.append("amphetamines")
        candidates.append("stimulants")
    if cat == "dissociative":
        candidates.append("dissociatives")
    if cat == "psychedelic":
        candidates.append("psychedelics")
    if cat == "alcohol":
        candidates.append("alcohol")
    if cat == "other":
        # try some common ones
        if d in {"cannabis", "weed", "marijuana"}:
            candidates.extend(["cannabis", "weed"])
        if d == "nicotine":
            candidates.append("nicotine")

    for cand in candidates:
        lc = cand.lower()
        if lc in TRIPSIT_COMBO_LABELS:
            return lc

    # fallback
    return d

def compute_tripsit_combo_penalty(drugs: List[str]) -> int:
    """
    Compute additional penalty based on TripSit combo chart.
    """
    if not TRIPSIT_COMBO_PENALTIES:
        return 0

    mapped = [map_drug_to_tripsit_label(d) for d in drugs]
    penalty = 0
    seen_pairs = set()

    for i in range(len(mapped)):
        for j in range(i + 1, len(mapped)):
            key = frozenset({mapped[i], mapped[j]})
            if key in seen_pairs:
                continue
            seen_pairs.add(key)
            penalty += TRIPSIT_COMBO_PENALTIES.get(key, 0)

    return penalty

# =============================================================================
# 4. NORMALISATION + CATEGORY INFERENCE + UNKNOWN HANDLING
# =============================================================================

def normalise_token(token: str) -> str:
    """Lowercase and canonicalise using SLANG_MAP and NORMALISATION_MAP."""
    token = token.lower().strip()

    # First map slang / street names to canonical drug names, if known
    if token in SLANG_MAP:
        token = SLANG_MAP[token]

    # Then apply normalisation rules (trace/low-conc variants, etc.)
    return NORMALISATION_MAP.get(token, token)


def infer_category_from_name(name: str) -> str:
    """
    Heuristic to guess a category for previously unseen drugs.
    """
    n = name.lower()
    if "nitazene" in n:
        return "nitazene"
    if "pinaca" in n or " cannabinoid" in n:
        return "other"
    if "cathinone" in n:
        return "stimulant"
    if n.endswith("pam") or n.endswith("lam"):
        return "benzodiazepine"
    if "ketamine" in n or "methoxetamine" in n or n == "mxe":
        return "dissociative"
    return "unknown"

def fuzzy_match_drug(token: str, known_drugs: list, max_distance: int = 2) -> str:
    """
    Fuzzy match token to closest known drug within max_distance.
    Returns the matched drug, or the original token if no safe match found.
    """
    token = token.lower().strip()
    best_match = None
    best_distance = 999

    for drug in known_drugs:
        dist = levenshtein(token, drug)
        if dist < best_distance:
            best_distance = dist
            best_match = drug

    if best_distance <= max_distance:
        return best_match  # safe correction

    return token  # no correction; handled as unknown


def get_drug_info(raw_token: str) -> Tuple[str, str, int, bool]:
    """
    Given a raw token, return (canonical_name, category, score, is_unknown).

    New substances are:
      - normalised,
      - assigned an inferred category,
      - given a conservative default score,
      - stored in DRUG_CONFIG,
      - flagged as 'unknown' if category == 'unknown'.
    """
    token = normalise_token(raw_token)

    # Apply fuzzy matching AFTER normalisation but BEFORE lookup
    token = fuzzy_match_drug(token, list(DRUG_CONFIG.keys()))

    if token in DRUG_CONFIG:
        info = DRUG_CONFIG[token]
        cat = str(info["category"])
        score = int(info["score"])
        return token, cat, score, (cat == "unknown")

    inferred_cat = infer_category_from_name(token)
    score = CATEGORY_DEFAULT_SCORE[inferred_cat]
    DRUG_CONFIG[token] = {"category": inferred_cat, "score": score}
    return token, inferred_cat, score, (inferred_cat == "unknown")

# =============================================================================
# 5. CATEGORY-LEVEL SYNERGY RULES
# =============================================================================

SYNERGY_PAIRS: List[Tuple[str, str]] = [
    ("opioid", "benzodiazepine"),
    ("opioid", "gabapentinoid"),
    ("benzodiazepine", "gabapentinoid"),
    ("opioid", "alcohol"),
    ("benzodiazepine", "alcohol"),
    ("opioid", "dissociative"),
    ("benzodiazepine", "dissociative"),
    ("opioid", "stimulant"),  # speedballing
]

# =============================================================================
# 6. PERSON-LEVEL CONTEXT MODIFIERS
# =============================================================================

def compute_context_modifier(context: dict, drugs: List[str]) -> Tuple[int, List[str]]:
    """
    Compute an additional score based on person-level vulnerability and history.
    Returns (context_score_adjustment, list_of_reasons).
    """
    ctx_score = 0
    reasons: List[str] = []

    categories = {DRUG_CONFIG[d]["category"] for d in drugs if d in DRUG_CONFIG}
    has_opioid = "opioid" in categories
    has_depressant = bool({"opioid", "benzodiazepine", "gabapentinoid",
                           "dissociative", "alcohol"} & categories)

    age = context.get("age")
    weight = context.get("weight_kg")
    height_cm = context.get("height_cm")
    sex = context.get("sex")  # collected for context / future use, not used in scoring

        opioid_dependent = context.get("opioid_dependent", False)
    homeless = context.get("homeless", False)
    recent_overdose = context.get("recent_overdose", False)
    severe_mental_health = context.get("severe_mental_health", False)
    polysubstance_history = context.get("polysubstance_history", False)

    # Age-related vulnerability
    if age is not None:
        if age <= 18:
            ctx_score += 1
            reasons.append("Young person (<=18) – increased vulnerability.")
        elif age >= 65:
            ctx_score += 2
            reasons.append("Older adult (>=65) – higher risk from CNS depressants.")

    # Body size: use BMI if we have both height and weight, otherwise fall back to simple weight check
    bmi = None
    if weight is not None and height_cm is not None and height_cm > 0:
        height_m = height_cm / 100.0
        bmi = weight / (height_m ** 2)

    if bmi is not None:
        if bmi < 16:
            ctx_score += 2
            reasons.append(
                f"Very low BMI ({bmi:.1f}) – severely underweight, higher effective exposure and frailty."
            )
        elif bmi < 18.5:
            ctx_score += 1
            reasons.append(
                f"Low BMI ({bmi:.1f}) – underweight, higher effective exposure to substances."
            )
    elif weight is not None and weight < 55:
        # Fallback if height is missing
        ctx_score += 1
        reasons.append("Low body weight (<55 kg) – higher effective exposure.")

        # Known opioid dependence – higher baseline risk
    if has_opioid and opioid_dependent:
        ctx_score += 2
        reasons.append("Known or suspected opioid dependence – higher baseline overdose and relapse risk.")

    # Social / clinical vulnerability
    if homeless:
        ctx_score += 3
        reasons.append("Person experiencing homelessness – unstable environment and reduced access to care.")
    if recent_overdose:
        ctx_score += 3
        reasons.append("Recent overdose – strong indicator for relapse and high mortality risk.")
    if severe_mental_health:
        ctx_score += 2
        reasons.append("Severe mental health difficulty – increased overall vulnerability.")
    if polysubstance_history and len(drugs) >= 3:
        ctx_score += 1
        reasons.append("History of polysubstance use plus current multiple substances.")

    # has_depressant, lives_alone, pregnancy, etc. could be added later
    return ctx_score, reasons


# =============================================================================
# 7. DRUG EXTRACTION + SCORING
# =============================================================================
STOPWORDS = {
    "and", "with", "plus", "&", "then", "after", "before",
    "to", "for", "of", "the", "a", "an", "took", "used",
    "had", "take", "taking", "some", "my", "his", "her",
    "their"
}

# Normalise multi-word phrases before tokenising
PHRASE_NORMALISATION = {
    "synthetic cannabinoid": "generic_synthetic_cannabinoid",
    "synthetic cannabinoids": "generic_synthetic_cannabinoid",
}


def extract_drugs(text: str) -> Tuple[List[str], List[str]]:
    """
    Parse free text and return:
      - list of canonical drugs,
      - list of 'unknown category' drugs.
      STOPWORDS (e.g. 'and', 'with') are ignored.
    """
    text = text.lower()

    # Apply phrase normalisation BEFORE splitting
    for phrase, replacement in PHRASE_NORMALISATION.items():
        text = text.replace(phrase, replacement)

    tokens = re.split(r"[ ,;\n]+", text)

    detected: List[str] = []
    unknowns: List[str] = []

    for token in tokens:
        token = token.strip()

        # Skip empty tokens and filler words like "and"
        if not token or token in STOPWORDS:
            continue

        canonical, cat, score, is_unknown = get_drug_info(token)
        detected.append(canonical)

        if is_unknown:
            unknowns.append(canonical)

    # Remove duplicates
    detected = list(dict.fromkeys(detected))
    unknowns = list(dict.fromkeys(unknowns))

    return detected, unknowns


def compute_drug_score(drugs: List[str]) -> Tuple[int, int, int]:
    """
    Compute:
      base + category-based synergy + TripSit combo penalties.

    Returns:
      (total_drug_score, category_synergy_component, tripsit_combo_component)
    """
    base = 0
    categories = set()

    for d in drugs:
        info = DRUG_CONFIG.get(d)
        if info is None:
            _, cat, score, _ = get_drug_info(d)
        else:
            cat = str(info["category"])
            score = int(info["score"])
        base += score
        categories.add(cat)

    category_synergy = 0
    for c1, c2 in SYNERGY_PAIRS:
        if c1 in categories and c2 in categories:
            category_synergy += 3

    tripsit_combo = compute_tripsit_combo_penalty(drugs)
    total = base + category_synergy + tripsit_combo
    return total, category_synergy, tripsit_combo

# =============================================================================
# 8. TRIAGE BRANCHES, LCMS PRIORITY, REFERRAL LOGIC
# =============================================================================

def triage_branch(score: int) -> dict:
    if score >= 12:
        return {
            "branch": "High risk",
            "interventions": [
                "Urgent referral to specialist addiction services.",
                "Consider opioid substitution therapy and supervised dosing for opioids.",
                "Provide take-home naloxone and overdose response training.",
                "Initiate medically supervised tapering for benzodiazepines or gabapentinoids.",
                "Offer comprehensive psychosocial and housing support where relevant.",
            ],
        }
    elif score >= 6:
        return {
            "branch": "Moderate risk",
            "interventions": [
                "Discuss harm-reduction strategies and monitor use closely.",
                "Assess for opioid substitution therapy or naltrexone where appropriate.",
                "Provide naloxone and training.",
                "Offer counselling and referral to community support services.",
            ],
        }
    else:
        return {
            "branch": "Low risk",
            "interventions": [
                "Provide education on safer use and harm-reduction.",
                "Offer brief interventions and monitor for escalation.",
                "No pharmacotherapy usually required.",
            ],
        }

def lcms_priority(score: int, unknown_drugs: List[str]) -> str:
    if unknown_drugs:
        return "High priority for LCMS confirmation (novel/unmapped substance detected)."
    if score >= 12:
        return "Consider LCMS confirmation if capacity allows (high-risk profile)."
    if score >= 6:
        return "LCMS useful but not essential; prioritise unknown/high-risk samples first."
    return "LCMS generally not required for triage; can be deprioritised if resources are limited."

def referral_recommendation(total_score: int, unknown_drugs: List[str], context: dict) -> dict:
    homeless = context.get("homeless", False)
    recent_overdose = context.get("recent_overdose", False)
    opioid_dependent = context.get("opioid_dependent", False)

    reasons = []
    urgent = False

    if homeless:
        reasons.append(
            "Person is experiencing homelessness – needs enhanced support and care coordination."
        )
        urgent = True

    if recent_overdose:
        reasons.append(
            "Recent overdose – strong indication for rapid clinical follow-up."
        )
        urgent = True

    if opioid_dependent:
        reasons.append(
            "Known or suspected opioid dependence – assessment for structured treatment recommended."
        )
        # not automatically 'urgent', but always a reason to refer

    if total_score >= 12:
        reasons.append("High overall triage score (>=12).")

    if unknown_drugs and total_score >= 8:
        reasons.append("Unknown substances present in a moderate/high-risk profile.")

    # key change: include opioid_dependent in the referral decision
    if urgent or opioid_dependent or total_score >= 12 or (unknown_drugs and total_score >= 8):
        priority = "urgent" if urgent else "soon"
        suggested_service = "NHS community addiction service / crisis team"
        if homeless:
            suggested_service += " + housing / outreach services"
        return {
            "refer": True,
            "priority": priority,
            "reason": "; ".join(reasons) if reasons else "Elevated risk profile.",
            "suggested_service": suggested_service,
        }

    return {
        "refer": False,
        "priority": "routine",
        "reason": "No immediate indicators for urgent referral; offer information and optional signposting.",
        "suggested_service": "Routine primary care or local drug service (if client wishes).",
    }

# =============================================================================
# 9. HIGH-LEVEL TRIAGE FUNCTION
# =============================================================================

def triage_from_text_and_context(text: str, context: dict) -> dict:
    """
    Master function: combines drugs, TripSit penalties, context, LCMS priority,
    and referral logic into one output dict.
    """
    drugs, unknowns = extract_drugs(text)
    drug_score, synergy_component, tripsit_component = compute_drug_score(drugs)
    ctx_score, ctx_reasons = compute_context_modifier(context, drugs)
    total_score = drug_score + ctx_score

    branch_info = triage_branch(total_score)
    lcms_note = lcms_priority(total_score, unknowns)
    referral_info = referral_recommendation(total_score, unknowns, context)

    alerts: List[str] = []

    if unknowns:
        alerts.append(
            f"Unidentified substance(s) detected: {', '.join(unknowns)}. "
            "These were assigned to an 'unknown' category with a conservative "
            "non-zero risk score and should be flagged for manual review and "
            "potential LCMS confirmation."
        )
    if ctx_reasons:
        alerts.append("Contextual vulnerability factors: " + " ".join(ctx_reasons))
    alerts.append(lcms_note)

    if referral_info["refer"]:
        alerts.append(
            f"Referral recommended ({referral_info['priority']}): {referral_info['reason']} "
            f"→ Suggested pathway: {referral_info['suggested_service']}."
        )
    else:
        alerts.append(
            f"No urgent referral required: {referral_info['reason']} "
            f"→ Suggested pathway: {referral_info['suggested_service']}."
        )

    return {
        "detected_drugs": drugs,
        "unknown_drugs": unknowns,
        "drug_score": drug_score,
        "synergy_component": synergy_component,
        "tripsit_combo_component": tripsit_component,
        "context_score": ctx_score,
        "total_score": total_score,
        "branch": branch_info["branch"],
        "interventions": branch_info["interventions"],
        "alerts": alerts,
        "referral": referral_info,
    }
def get_context_from_user() -> dict:
    """
    Collect person-level context from simple input 'boxes' (prompts).
    Blank answers are treated as unknown / False.
    """
    print("\n--- Client context (leave blank if unknown) ---")

    # Age
    age_str = input("Age: ").strip()
    age = int(age_str) if age_str.isdigit() else None

    # Weight
    weight_str = input("Weight in kg: ").strip()
    try:
        weight_kg = float(weight_str) if weight_str else None
    except ValueError:
        weight_kg = None
        
    # Height (optional)
    height_str = input("Height in cm (optional): ").strip()
    try:
        height_cm = float(height_str) if height_str else None
    except ValueError:
        height_cm = None

    # Sex / gender (optional; collected but not used in score)
    sex_str = input("Sex (e.g. male, female, other; optional): ").strip().lower() or None


    # Yes/No helper
    def yn(prompt: str) -> bool:
        ans = input(prompt + " [y/N]: ").strip().lower()
        return ans in {"y", "yes"}

    opioid_naive = yn("Opioid-naïve (no regular opioid use)?")
    homeless = yn("Is the person currently homeless or in very unstable housing?")
    recent_overdose = yn("Recent non-fatal overdose (e.g. last 3–6 months)?")
    severe_mental_health = yn("Severe mental health difficulty (e.g. psychosis, severe depression)?")
    polysubstance_history = yn("History of regular polysubstance use?")

    context = {
        "age": age,
        "weight_kg": weight_kg,
        "opioid_naive": opioid_naive,
        "homeless": homeless,
        "recent_overdose": recent_overdose,
        "severe_mental_health": severe_mental_health,
        "polysubstance_history": polysubstance_history,
        "weight_kg": weight_kg,
        "height_cm": height_cm,
        "sex": sex_str,
    }

    return context
def pretty_print_result(result: dict) -> None:
    print("\n============ TRIAGE RESULT ============")
    print(f"Detected drugs: {', '.join(result['detected_drugs']) or 'None'}")
    if result["unknown_drugs"]:
        print(f"Unknown drugs (flagged): {', '.join(result['unknown_drugs'])}")

    print(f"\nDrug score: {result['drug_score']}")
    print(f"  - Category synergy component: {result['synergy_component']}")
    print(f"  - TripSit combo component: {result['tripsit_combo_component']}")
    print(f"Context score: {result['context_score']}")
    print(f"TOTAL triage score: {result['total_score']}")

    print(f"\nRisk branch: {result['branch']}")
    print("Recommended interventions:")
    for item in result["interventions"]:
        print(f"  • {item}")

    print("\nAlerts and notes:")
    for a in result["alerts"]:
        print(f"  - {a}")

    print("\nReferral recommendation:")
    ref = result["referral"]
    print(f"  → Refer: {ref['refer']} (priority: {ref['priority']})")
    print(f"  → Reason: {ref['reason']}")
    print(f"  → Suggested service: {ref['suggested_service']}")
    print("=======================================\n")
